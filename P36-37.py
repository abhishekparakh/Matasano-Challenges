#Implement Secure Remote Password (SRP)
import os
import sys
import hashlib


class client:
    def __init__(self, P, g):
        self.P = P                #prime number
        self.g = g                #generator
        self.I, self.passwd = self.REPL()     #user knows this
        #sys.getsizeof gets the number of bytes in primeP
        random_num = int.from_bytes(os.urandom(sys.getsizeof(P)), sys.byteorder)
        self.a = random_num % P      #secret number generated by user


    #generate parameters to send to server
    def CtoS(self):
        self.A = pow(self.g, self.a, self.P)
        return self.I, self.A         #these values go to server


    #get parameters from server and does the secret key computation
    def compute(self, B, salt, k):
        uH = hashlib.sha256((str(self.A)+str(B)).encode()).hexdigest()
        u = int(uH, base=16) 
        xH = hashlib.sha256(salt + self.passwd.encode()).hexdigest()
        x = int(xH, base=16)
        S = pow((B - k*pow(self.g, x, self.P)), (self.a+u*x), self.P)
        S = 0       #attack by client  challenge 37
        K = hashlib.sha256(str(S).encode()).hexdigest()
        hashKclient = hashlib.sha256(K.encode()+salt).hexdigest()  #salt is in bytes
        return hashKclient          #this goes to the server

    def REPL(self):
        username = input("Enter your email address: ")
        password = input("Enter your password: ")
        return username, password


#server knows user's email address and password. User provides these during registration
#user
class server:
    def __init__(self, P, g):
        self.P = P                #prime number
        self.g = g                #generator
        self.I = "user"       #knows this from before
        self.passwd = "pass"        #knows this from before
        #sys.getsizeof gets the number of bytes in primeP
        random_num = int.from_bytes(os.urandom(sys.getsizeof(P)), sys.byteorder)
        self.b = random_num % P         #secret number generated by server

        self.salt = os.urandom(32)      #salt is in bytes
        xH = hashlib.sha256(self.salt + self.passwd.encode()).hexdigest()
        x = int(xH, base=16)
        self.v = pow(g, x, P)
        del x, xH


    #generate parameters to send to client
    def StoC(self, k):
        self.B = k * self.v + pow(self.g, self.b, self.P)
        return self.salt, self.B     #send these two values to Client

    #do the secret key computation
    def compute(self, A):      #receives A from client and knows B
        uH = hashlib.sha256((str(A)+str(self.B)).encode()).hexdigest()
        u = int(uH, base=16)
        S = pow(A*pow(self.v, u, self.P), self.b, self.P)
        self.K = hashlib.sha256(str(S).encode()).hexdigest()
        return None       #generated secret key

    def verify(self, hashKclient):
        hashKServer = hashlib.sha256(self.K.encode()+self.salt).hexdigest()
        return hashKclient == hashKServer


def main():

    #NIST prime
    primeP = int('ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024' \
                'e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd' \
                '3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec' \
                '6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f' \
                '24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361' \
                'c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552' \
                'bb9ed529077096966d670c354e4abc9804f1746c08ca237327fff' \
                'fffffffffffff', base=16)
    generator_g = 2    #given
    k = 3              #given

    C = client(primeP, generator_g)
    S = server(primeP, generator_g)

    I, A = C.CtoS()
    salt, B = S.StoC(k)

    A = 0      #attack by client  challenge 37
    S.compute(A)                         #returns nothing
    hashKclient = C.compute(B, salt, k)

    print(S.verify(hashKclient))




if __name__ == "__main__":
    main()